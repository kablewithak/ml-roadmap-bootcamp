Project Lazarus: The Causal Rejection Inference System.1. The Architecture: "The loop that heals itself"You are building a Closed-Loop Active Learning System. It is not just a model; it is a policy engine.The Data Flow:[User App] → [API Gateway] → [Feature Store (Feast)] → [Traffic Router (Redis)] → [Inference Service] → [Decision]Component 1: The State-Aware Traffic Router (The "Brain")Role: Decides whether to "Exploit" (use the model's prediction) or "Explore" (force an approval to learn).Technology: Redis (running Lua scripts for atomicity).Logic:Fetch daily_loss_budget from Redis.If budget_exhausted: Force Exploit mode.Else: Generate random float r (0.0 to 1.0).If r < epsilon (e.g., 0.01) AND hard_rules_pass: Force Approval. Log as treatment_group = 'explore'.Else: Use Model Prediction. Log as treatment_group = 'exploit'.Component 2: The Safety Valve (The "Brakes")Role: Prevents the "Explore" mode from doing something illegal or catastrophic.Implementation: A hard-coded rule engine (Python Class) that runs before the router.Rules:if age < 18: REJECT (Override Explore)if recent_bankruptcy == True: REJECT (Override Explore)Why this matters: It shows you understand Compliance. You aren't just a mad scientist; you are a banker.Component 3: The Causal Training Pipeline (The "Healer")Role: Retrains the model using Inverse Probability Weighting (IPW).The Math:Normal Loss Function: $L = (y - \hat{y})^2$Your Causal Loss Function: $L = \frac{1}{P(\text{approval})} \times (y - \hat{y})^2$Explanation: A loan approved in the "Explore" bucket (1% probability) is weighted 100x higher than a normal loan. This forces the model to pay massive attention to these "rare" data points, effectively "healing" its blindness to the rejected population.2. The Tech Stack (Aligned with your Roadmap)Language: Python 3.11 (Type-hinted, Pydantic models).Infrastructure: Docker & Docker Compose (simulating microservices).Feature Store: Feast (serving features like avg_txn_amt_30d).Model Serving: FastAPI (handling the inference endpoint).State/Routing: Redis (The critical component for the bandit logic).Monitoring: Grafana + Prometheus (Visualizing the "Cost of Exploration").Database: PostgreSQL (Storing the "Ground Truth" of loans).3. Transaction Volume & Simulation StrategyYou cannot wait 12 months for loan defaults. You must simulate time.The Simulation Script (lazarus_sim.py):You need a script that generates 100,000 applications in a "Time Warped" loop.Generate Synthetic Applicants: Use Faker to create users with features (Income, Debt, Credit Score).The Trick: Inject a Hidden Variable that the model doesn't see (e.g., "Gambling Addiction"). This represents real-world hidden risk.The Feedback Loop:Send applicant to your API.API decides: Approve or Reject.If Approved: The Simulator calculates if they "default" based on the Hidden Variable.If Rejected: We never know (unless they were in the "Explore" bucket!).Scale:Run 100,000 requests.This generates enough "Explore" data (~1,000 loans) to statistically prove the new model works.4. The "Undeniable" ArtifactsAt the end of Week 16, your repo must contain these three specific items to pass the "IQ Test":A. The "Cost of Knowledge" Grafana DashboardShutterstockPanel 1: "Current Loss Budget" (Starts at $1,000, ticks down as 'Explore' loans default).Panel 2: "Model Blindness Score" (A metric showing how confident the model is on rejected regions).Panel 3: "Projected Revenue Lift". This is the money maker. It calculates: (New Good Loans Found) x ($500 LTV) - (Cost of Exploration). If this number is positive, you are hired.B. The "Shadow Mode" Report (PDF)A comparison between Model_V1 (Standard) and Model_V2 (Causal).Headline: "How spending $450 on random approvals unlocked $12,000 in safe revenue."Visual: A chart showing the Decision Boundary shifting to include a previously rejected group (e.g., "High Income but Thin Credit History").C. The policy.py Code BlockRecruiters look for clean, defensive code. This specific snippet will stand out:Pythondef decide_application(user_features, risk_score):
    # 1. SAFETY VALVE (Compliance)
    if is_legally_prohibited(user_features):
        return Decision.REJECT, reason="COMPLIANCE_BLOCK"

    # 2. EXPLORATION LOGIC (The "IQ Test" part)
    # Atomic decrement of exploration budget in Redis
    current_budget = redis.get("loss_budget")
    
    if current_budget > 0 and random.random() < EPSILON:
        # We are BUYING data. We force approval to learn.
        # We tag this data so the model knows it was a 'forced' experiment.
        log_experiment_exposure(user_id, variant="EXPLORE")
        return Decision.APPROVE, reason="PROJECT_LAZARUS_EXPLORE"

    # 3. EXPLOITATION (Standard Business Logic)
    if risk_score > THRESHOLD:
        return Decision.APPROVE, reason="MODEL_Qualified"
    
    return Decision.REJECT, reason="MODEL_HighRisk"
Why This Specific Project WinsJunior/Mid Engineers optimize F1-Score.Senior Engineers optimize Latency.Staff/Principal Engineers optimize Economics.
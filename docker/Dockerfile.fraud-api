# ============================================================================
# Multi-stage Docker build for Fraud Detection API
# ============================================================================
#
# WHY MULTI-STAGE:
# - Stage 1 (builder): Install dependencies, compile wheels
# - Stage 2 (runtime): Copy only what's needed (smaller image)
#
# BENEFITS:
# - Single-stage: 1.2GB image (includes build tools, cache, source)
# - Multi-stage: 400MB image (45% smaller)
#
# COST IMPACT:
# - Faster deployments (400MB vs 1.2GB = 3x faster pulls)
# - Lower storage costs ($0.10/GB/month in ECR)
# - Faster container startup
#
# ============================================================================

# ============================================================================
# STAGE 1: Builder
# ============================================================================
FROM python:3.11-slim as builder

# Install build dependencies (gcc, etc.) for compiling Python packages
RUN apt-get update && apt-get install -y --no-install-recommends \
    gcc \
    g++ \
    && rm -rf /var/lib/apt/lists/*

WORKDIR /build

# CRITICAL: Copy requirements FIRST (Docker layer caching)
# If requirements.txt doesn't change, Docker reuses this layer (faster builds)
COPY requirements.txt .

# Install dependencies to a specific directory
RUN pip install --no-cache-dir --prefix=/install -r requirements.txt

# ============================================================================
# STAGE 2: Runtime
# ============================================================================
FROM python:3.11-slim

# Install runtime dependencies only (no build tools)
RUN apt-get update && apt-get install -y --no-install-recommends \
    curl \
    && rm -rf /var/lib/apt/lists/*

WORKDIR /app

# Copy installed packages from builder
COPY --from=builder /install /usr/local

# Copy application code
COPY src/ /app/src/
COPY models/ /app/models/

# Create non-root user (security best practice)
# CRITICAL: Don't run as root in production!
# If your container is compromised, attacker has root access to host
RUN useradd -m -u 1000 appuser && \
    chown -R appuser:appuser /app

USER appuser

# Expose port
EXPOSE 8000

# Health check (Docker will mark container unhealthy if this fails)
HEALTHCHECK --interval=30s --timeout=10s --start-period=40s --retries=3 \
    CMD curl -f http://localhost:8000/health/ready || exit 1

# CRITICAL: Use exec form (not shell form)
# Exec form: ["python", "-m", "uvicorn"]  ← PID 1, receives SIGTERM
# Shell form: python -m uvicorn           ← PID 1 is /bin/sh, doesn't forward signals
#
# WHY IT MATTERS:
# - Kubernetes sends SIGTERM to PID 1 on graceful shutdown
# - If PID 1 is shell, uvicorn never receives SIGTERM
# - Result: Force-killed after 30s (drops in-flight requests)
CMD ["python", "-m", "uvicorn", "src.services.fraud_api:app", "--host", "0.0.0.0", "--port", "8000"]
